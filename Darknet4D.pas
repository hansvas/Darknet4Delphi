unit Darknet4D;
{ This unit is automatically generated by Chet:
  https://github.com/neslib/Chet }

{$MINENUMSIZE 4}

interface
const
  DARKNET_WEIGHTS_VERSION_MAJOR = 0;
  DARKNET_WEIGHTS_VERSION_MINOR = 2;
  DARKNET_WEIGHTS_VERSION_PATCH = 5;
  DARKNET_WEIGHTS_VERSION_TWEAK = 4;
  DARKNET_VERSION_STRINGS = 'v3.0-200-g4ede63e9';
  DARKNET_VERSION_SHORTS  = '3.0.200';
  DARKNET_VERSION_KEYWORD = 'Jazz';

type
  // Forward declarations
  PPUTF8Char = ^PUTF8Char;

  PDarknetBox = ^DarknetBox;
  PDarknetDetection = ^DarknetDetection;
  PDarknetImage = ^DarknetImage;

  /// An opaque pointer to a @ref Darknet::Network object, without needing to expose the internals of the network structure.
  DarknetNetworkPtr = Pointer;
  PDarknetNetworkPtr = ^DarknetNetworkPtr;

  /// Bounding box used with normalized coordinates (between 0.0 and 1.0).
  DarknetBox = record
    x: Single;
    y: Single;
    w: Single;
    h: Single;
  end;

  (** Everything %Darknet knows about a specific detection.  This structure is used by the old API.  If using the new API,
   * use @ref Darknet::Prediction instead.
   *)
  DarknetDetection = record
    /// bounding boxes are normalized (between 0.0f and 1.0f)
    bbox: DarknetBox;
    classes: Integer;
    best_class_idx: Integer;
    prob: PSingle;
    mask: PSingle;
    objectness: Single;
    sort_class: Integer;
    /// Gaussian_YOLOv3 - tx,ty,tw,th uncertainty
    uc: PSingle;
    /// bit-0 - center, bit-1 - top-left-corner, bit-2 - bottom-right-corner
    points: Integer;
    /// embeddings for tracking
    embeddings: PSingle;
    embedding_size: Integer;
    sim: Single;
    track_id: Integer;
  end;

  detection = DarknetDetection;

  Pdetection = ^DarknetDetection;

  (** The structure @ref DarknetImage is used to store a normalized RGB %Darknet image.  The format is intended to be
   * used for internal use by %Darknet, but there are some situations where it may also be used or referenced externally
   * via the %Darknet API.
   *
   * Moving forward starting with %Darknet V3 (August 2024), where possible the emphasis will be to use OpenCV @p cv::Mat
   * objects in the external-facing API instead of @ref DarknetImage.  Internally, %Darknet will continue to use @p Image.
   *
   * @warning Keep this structure as POD (plain-old-data) since there are many places in the old code where memory for
   * these image objects is calloc'd.  This structure was originally part of the old %Darknet @p C API, which is why it
   * exists this way and not as a C++ class with methods.
   *
   * Within @p data, the image is stored as 3 non-interlaced channels in RGB order.  Each channel is stored as rows, from top to bottom.
   * So a 5x3 RGB image would look like this:
   *
   * ~~~~{.txt}
   *		r r r r r
   *		r r r r r
   *		r r r r r
   *		g g g g g
   *		g g g g g
   *		g g g g g
   *		b b b b b
   *		b b b b b
   *		b b b b b
   * ~~~~
   *
   * A 5x3 pure red image, with a blueish/green square in the bottom-right corner would look like this:
   *
   * ~~~~{.txt}
   *		1.0 1.0 1.0 1.0 1.0 // red channel
   *		1.0 1.0 1.0 0.0 0.0 // note the lack of red in the bottom-right corner
   *		1.0 1.0 1.0 0.0 0.0
   *		0.0 0.0 0.0 0.0 0.0 // green channel
   *		0.0 0.0 0.0 0.5 0.5
   *		0.0 0.0 0.0 0.5 0.5
   *		0.0 0.0 0.0 0.0 0.0 // blue channel
   *		0.0 0.0 0.0 1.0 1.0 // note the blue square in the bottom-right corner
   *		0.0 0.0 0.0 1.0 1.0
   * ~~~~
   *
   * For additional information or to help debug the internals of @p DarknetImage, see @ref Darknet::image_as_debug_string().
   *
   * @see @ref Darknet::load_image()
   * @see @ref Darknet::copy_image()
   * @see @ref make_empty_image()
   * @see @ref make_image()
   * @see @ref Darknet::free_image()
   *)
  DarknetImage = record
    /// width
    w: Integer;
    /// height
    h: Integer;
    /// channel
    c: Integer;
    /// normalized floats, the number of which is determined by @p "w * h * c"
    data: PSingle;
  end;

  /// @see @ref diounms_sort()
  NMS_KIND = (
    DEFAULT_NMS = 0,
    GREEDY_NMS = 1,
    DIOU_NMS = 2,
    CORNERS_NMS = 3);
  PNMS_KIND = ^NMS_KIND;
  /// Bounding box used with normalized coordinates (between 0.0 and 1.0).
  box = DarknetBox;

  /// Darknet-style image (vector of floats).
  Image = DarknetImage;
  pImage = ^Image;



var

  /// This is the @p C equivalent to @ref Darknet::show_version_info().
 darknet_show_version_info : procedure (); cdecl;

  /// Return the full version string, such as @p "v3.0-163-g56145bf".  @see @ref DARKNET_VERSION_STRING
 darknet_version_string : function (): PUTF8Char; cdecl;

 /// Return the short version string, such as @p "3.0.163".  @see @ref DARKNET_VERSION_SHORT
 darknet_version_short : function (): PUTF8Char; cdecl;

 /// This is the @p C equivalent to @ref Darknet::set_verbose().
 darknet_set_verbose : procedure (const flag: Boolean); cdecl;

 /// This is the @p C equivalent to @ref Darknet::set_trace().
 darknet_set_trace : procedure (const flag: Boolean); cdecl;

 /// This is the @p C equivalent to @ref Darknet::set_gpu_index().
 darknet_set_gpu_index : procedure (idx: Integer); cdecl;

 /// This is the @p C equivalent to @ref Darknet::set_detection_threshold().
 darknet_set_detection_threshold : procedure (ptr: DarknetNetworkPtr; threshold: Single); cdecl;

 /// This is the @p C equivalent to @ref Darknet::set_non_maximal_suppression_threshold().
 darknet_set_non_maximal_suppression_threshold : procedure (ptr: DarknetNetworkPtr; threshold: Single); cdecl;

 /// This is the @p C equivalent to @ref Darknet::fix_out_of_bound_values().
 darknet_fix_out_of_bound_values : procedure (ptr: DarknetNetworkPtr; const toggle: Boolean); cdecl;

 /// This is the @p C equivalent to @ref Darknet::network_dimensions().
darknet_network_dimensions : procedure (ptr: DarknetNetworkPtr; var w, h, c: Integer); cdecl;

 /// This is the @p C equivalent to @ref Darknet::load_neural_network().
 darknet_load_neural_network : function
  (const cfg_filename: PUTF8Char; const names_filename: PUTF8Char; const weights_filename: PUTF8Char): DarknetNetworkPtr; cdecl;

 /// This is the @p C equivalent to @ref Darknet::free_neural_network().
 darknet_free_neural_network : procedure (ptr: PDarknetNetworkPtr); cdecl;

 /// This is the @p C equivalent to @ref Darknet::clear_skipped_classes().
 darknet_clear_skipped_classes : procedure (ptr: DarknetNetworkPtr); cdecl;

 /// This is the @p C equivalent to @ref Darknet::add_skipped_class().
 darknet_add_skipped_class : procedure (ptr: DarknetNetworkPtr; const class_to_skip: Integer); cdecl;

 /// This is the @p C equivalent to @ref Darknet::del_skipped_classes().
 darknet_del_skipped_class : procedure (ptr: DarknetNetworkPtr; const class_to_include: Integer); cdecl;


 // ----------------------------------------------------------------------------

 (** @{ This is part of the original @p C API.  Do not use in new code.
 *
 * @see @ref darknet_load_neural_network()
 * @see @ref Darknet::load_neural_network()
 *)
 load_network        : function (const cfg: PUTF8Char; const weights: PUTF8Char; clear: Integer): DarknetNetworkPtr; cdecl;
 load_network_custom : function (const cfg: PUTF8Char; const weights: PUTF8Char; clear: Integer; batch: Integer): DarknetNetworkPtr; cdecl;

(** This is part of the original @p C API.  Do not use in new code.
 *
 * @see @ref darknet_free_neural_network()
 * @see @ref Darknet::free_neural_network()
 *
 * If you were previously using @ref free_network() from within @p C code, please use @p free_network_ptr() instead by
 * passing in the @em address of the network structure (pointer to the network).
 *
 * @note See the additional comments in @ref free_network().
 *)
 free_network_ptr : procedure (ptr: DarknetNetworkPtr); cdecl;

(** This is part of the original @p C API.  Do not use in new code.
 *
 * @see @ref darknet_load_neural_network()
 * @see @ref Darknet::load_neural_network()
 *
 * If you were previously using @p calculate_binary_weights() from within @p C code, it used to pass the network by
 * value.  Starting with %Darknet V3 in 2024-08-16, the network is now passed in as a pointer.
 *)
 calculate_binary_weights : procedure (ptr: DarknetNetworkPtr); cdecl;


(** This is part of the original @p C API.  Do not use in new code.
 *
 * @see @ref network_predict_image()
 * @see @ref Darknet::predict()
 *
 * If you were previously using @ref network_predict() from within @p C code, please use @p network_predict_ptr() instead
 * by passing in the @em address of the network structure (pointer to the network).
 *)
 network_predict_ptr : function (ptr: DarknetNetworkPtr; input: PSingle): PSingle; cdecl;


(** This is part of the original @p C API.  Do not use in new code.
 *
 * @see @ref network_predict_ptr()
 * @see @ref Darknet::predict()
 *)
network_predict_image : function (ptr: DarknetNetworkPtr; const im: DarknetImage): PSingle; cdecl;


(** This is part of the original @p C API.  Do not use in new code.
 *
 * You must call @ref free_detections() to free up memory once done with the detections.
 *
 * @see @ref Darknet::predict()
 * @see @ref free_detections()
 *)
 get_network_boxes : function
  (ptr: DarknetNetworkPtr; w: Integer; h: Integer; thresh: Single; hier: Single; map: PInteger; relative: Integer; num: PInteger; letter: Integer): Pdetection; cdecl;


 /// This is part of the original @p C API.  Do not use in new code.
 free_detections : procedure (dets: Pdetection; n: Integer); cdecl;


(** This is part of the original @p C API.  Make an empty image with the given dimensions.  The data pointer will be
 * @p nullptr.
 *
 * @see @ref free_image()
 * @see @ref make_image()
 *)
 make_empty_image : function (w: Integer; h: Integer; c: Integer): DarknetImage; cdecl;


(** This is part of the original @p C API.  Similar to @ref make_empty_image() but the data pointer is fully allocated.
 * @see @ref free_image()
 *)
make_image : function (w: Integer; h: Integer; c: Integer): DarknetImage; cdecl;

(** This is part of the original @p C API.  Free the data pointer that stores the image .  All image objects @em must
 * eventually call either this function or @ref Darknet::free_image() to prevent memory leaks.
 *
 * @see @ref Darknet::free_image()
 *
 * @note The @ref image is passed by value, meaning that the data pointer in the caller's copy of the image will
 * be left dangling.  Be careful not to reference it once this call returns.  Where possible when using C++, call
 * @ref Darknet::free_image() instead.
 *)
 free_image : procedure (im: image); cdecl;


 /// This is part of the original @p C API.  Non Maxima Suppression.
 do_nms_sort : procedure (dets: Pdetection; total: Integer; classes: Integer; thresh: Single); cdecl;


 /// This is part of the original @p C API.  Non Maxima Suppression.
 do_nms_obj : procedure (dets: Pdetection; total: Integer; classes: Integer; thresh: Single); cdecl;

 /// This is part of the original @p C API.  Non Maxima Suppression.
 diounms_sort : procedure (dets: Pdetection; total: Integer; classes: Integer; thresh: Single; nms_kind: NMS_KIND; beta1: Single); cdecl;

 /// This is part of the original @p C API.  Convert from data pointer to a %Darknet image.  Used by the Python API.
 copy_image_from_bytes : procedure (im: DarknetImage; pdata: PUTF8Char); cdecl;

 /// This is part of the original @p C API.  This function does nothing when %Darknet was built to run on the CPU.
 cuda_set_device : procedure (n: Integer); cdecl;

 /// This is part of the original @p C API.
 make_network_boxes : function (ptr: DarknetNetworkPtr; thresh: Single; num: PInteger): Pdetection; cdecl;

 /// This is part of the original @p C API.
 free_ptrs : procedure (ptrs: PPointer; n: Integer); cdecl;

 /// This is part of the original @p C API.
 reset_rnn : procedure (ptr: DarknetNetworkPtr); cdecl;

 /// This is part of the original @p C API.  This function exists for the Python API.
 load_image_v2 : function (const filename: PUTF8Char; desired_width: Integer; desired_height: Integer; channels: Integer): DarknetImage; cdecl;

  /// This is part of the original @p C API.
 network_predict_image_letterbox : function (ptr: DarknetNetworkPtr; im: DarknetImage): PSingle; cdecl;

 {getopt_internal : function (p1: Integer; const p2: PPUTF8Char; const p3: PUTF8Char; const p4: Poption; p5: PInteger; p6: Integer): Integer; cdecl;
  parse_long_options : function (const p1: PPUTF8Char; const p2: PUTF8Char; const p3: Poption; p4: PInteger; p5: Integer): Integer; cdecl;
  gcd : function (p1: Integer; p2: Integer): Integer; cdecl;
  permute_args : procedure (p1: Integer; p2: Integer; p3: Integer; const p4: PPUTF8Char); cdecl;

_vwarnx : procedure (const fmt: PUTF8Char; ap: Pointer); cdecl;

warnx : procedure (const fmt: PUTF8Char) varargs; cdecl;

// gcd : function (a: Integer; b: Integer): Integer; cdecl;

permute_args : procedure (panonopt_start: Integer; panonopt_end: Integer; opt_end: Integer; const nargv: PPUTF8Char); cdecl;

getopt : function (nargc: Integer; const nargv: PPUTF8Char; const options: PUTF8Char): Integer; cdecl;

getopt_long : function (nargc: Integer; const nargv: PPUTF8Char; const options: PUTF8Char; const long_options: Poption; idx: PInteger): Integer; cdecl;
  external dx name _PU + 'getopt_long';

function getopt_long_only(nargc: Integer; const nargv: PPUTF8Char; const options: PUTF8Char; const long_options: Poption; idx: PInteger): Integer; cdecl;
  external dx name _PU + 'getopt_long_only';

function gettimeofday(p1: Ptimeval; p2: Ptimezone): Integer; cdecl;
  external dx name _PU + 'gettimeofday';

function clock_gettime(p1: Integer; p2: Ptimespec): Integer; cdecl;
  external dx name _PU + 'clock_gettime'; }

procedure LoadLibDarknet(const P: String; raiseError : Boolean = True);

implementation
uses SysUtils,
  Math,
  Windows;

var
  Handle: HModule = 0;
  module: String = '';

function ProcAddress(h: HModule; lpProcName: LPCWSTR): FarProc;
begin
  result := GetProcAddress(h, lpProcName);
  if result = nil then
    raise Exception.Create(lpProcName + ' not in module ' + module);
end;


procedure LoadLibDarknet(const P: String; raiseError : Boolean = True);
var
  ret: Integer;
  err: String;
begin
  // Laden nur wenn noch nicht geladen
  if Handle <> 0 then
    exit;

  module := P;
  Handle := SafeLoadLibrary(P,SEM_FAILCRITICALERRORS);
  if Handle = 0 then
  begin
    ret := GetLastError();
    err := SysErrorMessage(ret);
    if raiseError then
       raise Exception.Create(err)
    else
       Writeln(err);
  end;

    darknet_show_version_info := ProcAddress(Handle, 'darknet_show_version_info');
    darknet_version_string    := ProcAddress(Handle, 'darknet_version_string');
    darknet_version_short     := ProcAddress(Handle, 'darknet_version_short');
    darknet_set_verbose       := ProcAddress(Handle, 'darknet_set_verbose');
    darknet_set_trace         := ProcAddress(Handle, 'darknet_set_trace');
    darknet_set_gpu_index     := ProcAddress(Handle, 'darknet_set_gpu_index');
    darknet_set_detection_threshold := ProcAddress(Handle, 'darknet_set_detection_threshold');
    darknet_set_non_maximal_suppression_threshold:= ProcAddress(Handle, 'darknet_set_non_maximal_suppression_threshold');
    darknet_fix_out_of_bound_values:= ProcAddress(Handle, 'darknet_fix_out_of_bound_values');
    darknet_network_dimensions:= ProcAddress(Handle, 'darknet_network_dimensions');
    darknet_load_neural_network:= ProcAddress(Handle, 'darknet_load_neural_network');
    darknet_free_neural_network:= ProcAddress(Handle, 'darknet_free_neural_network');
    darknet_clear_skipped_classes:= ProcAddress(Handle, 'darknet_clear_skipped_classes');
    darknet_add_skipped_class:= ProcAddress(Handle, 'darknet_add_skipped_class');
    darknet_del_skipped_class := ProcAddress(Handle, 'darknet_del_skipped_class');
    load_network := ProcAddress(Handle, 'load_network');
    load_network_custom := ProcAddress(Handle, 'load_network_custom');
    free_network_ptr := ProcAddress(Handle, 'free_network_ptr');
    calculate_binary_weights := ProcAddress(Handle, 'calculate_binary_weights');
    network_predict_ptr := ProcAddress(Handle, 'network_predict_ptr');
    network_predict_image := ProcAddress(Handle, 'network_predict_image');
    get_network_boxes := ProcAddress(Handle, 'get_network_boxes');
    free_detections := ProcAddress(Handle, 'free_detections');
    make_empty_image := ProcAddress(Handle, 'make_empty_image');
    make_image := ProcAddress(Handle, 'make_image');
    free_image := ProcAddress(Handle, 'free_image');
    do_nms_sort := ProcAddress(Handle, 'do_nms_sort');
    do_nms_obj := ProcAddress(Handle, 'do_nms_obj');
    diounms_sort := ProcAddress(Handle, 'diounms_sort');
    copy_image_from_bytes := ProcAddress(Handle, 'copy_image_from_bytes');
    cuda_set_device := ProcAddress(Handle, 'cuda_set_device');
    make_network_boxes := ProcAddress(Handle, 'make_network_boxes');
    free_ptrs := ProcAddress(Handle, 'free_ptrs');
    reset_rnn := ProcAddress(Handle, 'reset_rnn');
    load_image_v2 := ProcAddress(Handle, 'load_image_v2');
    network_predict_image_letterbox := ProcAddress(Handle, 'network_predict_image_letterbox');


end;


end.