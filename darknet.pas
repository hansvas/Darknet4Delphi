unit darknet;
{ This unit is automatically generated by Chet:
  https://github.com/neslib/Chet }

{$MINENUMSIZE 4}

interface

const
  {$IF Defined(WIN32)}
  libDark = 'libDarknet';
  _PU = '';
  {$ELSEIF Defined(WIN64)}
  libDark = 'libDarknet';
  _PU = '';
  {$ELSE}
    {$MESSAGE Error 'Unsupported platform'}
  {$ENDIF}

const
  DARKNET_WEIGHTS_VERSION_MAJOR = 0;
  DARKNET_WEIGHTS_VERSION_MINOR = 2;
  DARKNET_WEIGHTS_VERSION_PATCH = 5;
  DARKNET_WEIGHTS_VERSION_TWEAK = 4;
  DARKNET_VERSION_STRING = 'v3.0-200-g4ede63e9';
  DARKNET_VERSION_SHORT = '3.0.200';
  DARKNET_VERSION_KEYWORD = 'Jazz';

type
  // Forward declarations
  PDarknetBox = ^DarknetBox;
  PDarknetDetection = ^DarknetDetection;
  PDarknetImage = ^DarknetImage;

  /// An opaque pointer to a @ref Darknet::Network object, without needing to expose the internals of the network structure.
  DarknetNetworkPtr = Pointer;
  PDarknetNetworkPtr = ^DarknetNetworkPtr;

  /// Bounding box used with normalized coordinates (between 0.0 and 1.0).
  DarknetBox = record
    x: Single;
    y: Single;
    w: Single;
    h: Single;
  end;

  (** Everything %Darknet knows about a specific detection.  This structure is used by the old API.  If using the new API,
   * use @ref Darknet::Prediction instead.
   *)
  DarknetDetection = record
    /// bounding boxes are normalized (between 0.0f and 1.0f)
    bbox: DarknetBox;
    classes: Integer;
    best_class_idx: Integer;
    prob: PSingle;
    mask: PSingle;
    objectness: Single;
    sort_class: Integer;
    /// Gaussian_YOLOv3 - tx,ty,tw,th uncertainty
    uc: PSingle;
    /// bit-0 - center, bit-1 - top-left-corner, bit-2 - bottom-right-corner
    points: Integer;
    /// embeddings for tracking
    embeddings: PSingle;
    embedding_size: Integer;
    sim: Single;
    track_id: Integer;
  end;

  (** The structure @ref DarknetImage is used to store a normalized RGB %Darknet image.  The format is intended to be
   * used for internal use by %Darknet, but there are some situations where it may also be used or referenced externally
   * via the %Darknet API.
   *
   * Moving forward starting with %Darknet V3 (August 2024), where possible the emphasis will be to use OpenCV @p cv::Mat
   * objects in the external-facing API instead of @ref DarknetImage.  Internally, %Darknet will continue to use @p Image.
   *
   * @warning Keep this structure as POD (plain-old-data) since there are many places in the old code where memory for
   * these image objects is calloc'd.  This structure was originally part of the old %Darknet @p C API, which is why it
   * exists this way and not as a C++ class with methods.
   *
   * Within @p data, the image is stored as 3 non-interlaced channels in RGB order.  Each channel is stored as rows, from top to bottom.
   * So a 5x3 RGB image would look like this:
   *
   * ~~~~{.txt}
   *		r r r r r
   *		r r r r r
   *		r r r r r
   *		g g g g g
   *		g g g g g
   *		g g g g g
   *		b b b b b
   *		b b b b b
   *		b b b b b
   * ~~~~
   *
   * A 5x3 pure red image, with a blueish/green square in the bottom-right corner would look like this:
   *
   * ~~~~{.txt}
   *		1.0 1.0 1.0 1.0 1.0 // red channel
   *		1.0 1.0 1.0 0.0 0.0 // note the lack of red in the bottom-right corner
   *		1.0 1.0 1.0 0.0 0.0
   *		0.0 0.0 0.0 0.0 0.0 // green channel
   *		0.0 0.0 0.0 0.5 0.5
   *		0.0 0.0 0.0 0.5 0.5
   *		0.0 0.0 0.0 0.0 0.0 // blue channel
   *		0.0 0.0 0.0 1.0 1.0 // note the blue square in the bottom-right corner
   *		0.0 0.0 0.0 1.0 1.0
   * ~~~~
   *
   * For additional information or to help debug the internals of @p DarknetImage, see @ref Darknet::image_as_debug_string().
   *
   * @see @ref Darknet::load_image()
   * @see @ref Darknet::copy_image()
   * @see @ref make_empty_image()
   * @see @ref make_image()
   * @see @ref Darknet::free_image()
   *)
  DarknetImage = record
    /// width
    w: Integer;
    /// height
    h: Integer;
    /// channel
    c: Integer;
    /// normalized floats, the number of which is determined by @p "w * h * c"
    data: PSingle;
  end;

/// This is the @p C equivalent to @ref Darknet::show_version_info().
procedure darknet_show_version_info(); cdecl;
  external libDark name _PU + 'darknet_show_version_info';

/// Return the full version string, such as @p "v3.0-163-g56145bf".  @see @ref DARKNET_VERSION_STRING
function darknet_version_string(): PUTF8Char; cdecl;
  external libDark name _PU + 'darknet_version_string';

/// Return the short version string, such as @p "3.0.163".  @see @ref DARKNET_VERSION_SHORT
function darknet_version_short(): PUTF8Char; cdecl;
  external libDark name _PU + 'darknet_version_short';

/// This is the @p C equivalent to @ref Darknet::set_verbose().
procedure darknet_set_verbose(const flag: Boolean); cdecl;
  external libDark name _PU + 'darknet_set_verbose';

/// This is the @p C equivalent to @ref Darknet::set_trace().
procedure darknet_set_trace(const flag: Boolean); cdecl;
  external libDark name _PU + 'darknet_set_trace';

/// This is the @p C equivalent to @ref Darknet::set_gpu_index().
procedure darknet_set_gpu_index(idx: Integer); cdecl;
  external libDark name _PU + 'darknet_set_gpu_index';

/// This is the @p C equivalent to @ref Darknet::set_detection_threshold().
procedure darknet_set_detection_threshold(ptr: DarknetNetworkPtr; threshold: Single); cdecl;
  external libDark name _PU + 'darknet_set_detection_threshold';

/// This is the @p C equivalent to @ref Darknet::set_non_maximal_suppression_threshold().
procedure darknet_set_non_maximal_suppression_threshold(ptr: DarknetNetworkPtr; threshold: Single); cdecl;
  external libDark name _PU + 'darknet_set_non_maximal_suppression_threshold';

/// This is the @p C equivalent to @ref Darknet::fix_out_of_bound_values().
procedure darknet_fix_out_of_bound_values(ptr: DarknetNetworkPtr; const toggle: Boolean); cdecl;
  external libDark name _PU + 'darknet_fix_out_of_bound_values';

/// This is the @p C equivalent to @ref Darknet::network_dimensions().
procedure darknet_network_dimensions(ptr: DarknetNetworkPtr; w: PInteger; h: PInteger; c: PInteger); cdecl;
  external libDark name _PU + 'darknet_network_dimensions';

/// This is the @p C equivalent to @ref Darknet::load_neural_network().
function darknet_load_neural_network(const cfg_filename: PUTF8Char; const names_filename: PUTF8Char; const weights_filename: PUTF8Char): DarknetNetworkPtr; cdecl;
  external libDark name _PU + 'darknet_load_neural_network';

/// This is the @p C equivalent to @ref Darknet::free_neural_network().
procedure darknet_free_neural_network(ptr: PDarknetNetworkPtr); cdecl;
  external libDark name _PU + 'darknet_free_neural_network';

/// This is the @p C equivalent to @ref Darknet::clear_skipped_classes().
procedure darknet_clear_skipped_classes(ptr: DarknetNetworkPtr); cdecl;
  external libDark name _PU + 'darknet_clear_skipped_classes';

/// This is the @p C equivalent to @ref Darknet::add_skipped_class().
procedure darknet_add_skipped_class(ptr: DarknetNetworkPtr; const class_to_skip: Integer); cdecl;
  external libDark name _PU + 'darknet_add_skipped_class';

/// This is the @p C equivalent to @ref Darknet::del_skipped_classes().
procedure darknet_del_skipped_class(ptr: DarknetNetworkPtr; const class_to_include: Integer); cdecl;
  external libDark name _PU + 'darknet_del_skipped_class';

implementation

end.